<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ambient AI VCP System</title>
    <link rel="stylesheet" href="/assets/fonts/fonts.css">
    <style>
        :root {
            --bg: #070b12;
            --surface: #0d1321;
            --surface-2: #111827;
            --border: rgba(0, 212, 170, 0.12);
            --border-hover: rgba(0, 212, 170, 0.35);
            --accent: #00d4aa;
            --accent-dim: rgba(0, 212, 170, 0.1);
            --accent-glow: rgba(0, 212, 170, 0.35);
            --amber: #f59e0b;
            --red: #ef4444;
            --blue: #3b82f6;
            --text: #e2e8f0;
            --text-muted: #64748b;
            --text-dim: #94a3b8;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Syne', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image: radial-gradient(circle, rgba(0, 212, 170, 0.055) 1px, transparent 1px);
            background-size: 32px 32px;
            pointer-events: none;
            z-index: 0;
        }

        body::after {
            content: '';
            position: fixed;
            top: -200px;
            left: 50%;
            transform: translateX(-50%);
            width: 900px;
            height: 500px;
            background: radial-gradient(ellipse, rgba(0, 212, 170, 0.07) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
        }

        .layout {
            position: relative;
            z-index: 1;
            max-width: 1440px;
            margin: 0 auto;
            padding: 32px 24px;
        }

        /* Header */
        .header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 24px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }

        .logo-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 8px;
        }

        .logo-mark {
            width: 44px;
            height: 44px;
            background: var(--accent-dim);
            border: 1px solid var(--border-hover);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px var(--accent-glow);
        }

        .logo-mark svg {
            width: 22px;
            height: 22px;
            stroke: var(--accent);
        }

        h1 {
            font-size: 26px;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        h1 span { color: var(--accent); }

        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            letter-spacing: 0.1em;
            margin-bottom: 18px;
        }

        .connect-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .header-connect {
            margin-top: 10px;
        }

        .connect-bar.form-connect-bar {
            margin-top: 12px;
            justify-content: flex-start;
        }

        .connect-bar label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            white-space: nowrap;
        }

        .connect-bar input {
            flex: 1;
            min-width: 280px;
            max-width: 380px;
            padding: 9px 14px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .connect-bar input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-dim);
        }

        .header-connect input {
            max-width: 460px;
        }

        .connect-status {
            width: 100%;
            margin-top: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
        }

        .connect-status.success { color: var(--accent); }
        .connect-status.error { color: var(--red); }

        .header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            padding-top: 4px;
        }

        .live-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 7px 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--red);
            letter-spacing: 0.1em;
            transition: border-color 0.2s ease, color 0.2s ease;
        }

        .live-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: var(--red);
            box-shadow: 0 0 8px var(--red);
            transition: background 0.2s ease, box-shadow 0.2s ease;
        }

        .live-badge.connected {
            color: var(--accent);
            border-color: rgba(45, 212, 191, 0.45);
        }

        .live-badge.connected .live-dot {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
            animation: blink 2s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .refresh-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
        }

        /* Buttons */
        .btn {
            padding: 9px 20px;
            background: var(--accent);
            color: #070b12;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Syne', sans-serif;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.02em;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn:hover {
            background: #00f5c4;
            box-shadow: 0 0 20px var(--accent-glow);
            transform: translateY(-1px);
        }

        .btn:active { transform: translateY(0); box-shadow: none; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .btn-ghost {
            background: transparent;
            color: var(--accent);
            border: 1px solid var(--border-hover);
        }

        .btn-ghost:hover {
            background: var(--accent-dim);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Auth Section */
        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .auth-tab {
            flex: 1;
            padding: 10px 20px;
            background: transparent;
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Syne', sans-serif;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .auth-tab.active {
            background: var(--accent-dim);
            color: var(--accent);
            border-color: var(--border-hover);
        }

        .auth-tab:hover {
            border-color: var(--border-hover);
        }

        .auth-form {
            margin-top: 20px;
        }

        .auth-form .form-group {
            margin-bottom: 16px;
        }

        .auth-form button[type="submit"] {
            width: 100%;
            margin-top: 10px;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        @media (max-width: 900px) { .stats-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 480px) { .stats-grid { grid-template-columns: 1fr; } }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 24px;
            position: relative;
            overflow: hidden;
            transition: border-color 0.3s, transform 0.3s;
            animation: fadeUp 0.5s ease both;
        }

        .stat-card:nth-child(1) { animation-delay: 0.05s; }
        .stat-card:nth-child(2) { animation-delay: 0.1s; }
        .stat-card:nth-child(3) { animation-delay: 0.15s; }
        .stat-card:nth-child(4) { animation-delay: 0.2s; }

        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(16px); }
            to   { opacity: 1; transform: translateY(0); }
        }

        .stat-card::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent), transparent);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .stat-card:hover { border-color: var(--border-hover); transform: translateY(-3px); }
        .stat-card:hover::after { opacity: 1; }

        .stat-icon {
            font-size: 20px;
            margin-bottom: 14px;
            display: block;
            color: var(--accent);
            opacity: 0.7;
        }

        .stat-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .stat-value {
            font-size: 38px;
            font-weight: 800;
            color: var(--accent);
            line-height: 1;
            margin-bottom: 6px;
            font-variant-numeric: tabular-nums;
        }

        .stat-sub { font-size: 12px; color: var(--text-muted); }

        /* Sections */
        .section {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 28px;
            margin-bottom: 20px;
            animation: fadeUp 0.5s ease 0.25s both;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 22px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
            font-weight: 700;
        }

        .count-badge {
            background: var(--accent-dim);
            color: var(--accent);
            border: 1px solid rgba(0, 212, 170, 0.2);
            border-radius: 6px;
            padding: 2px 9px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        /* Table */
        .table-wrap { overflow-x: auto; }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        table th {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            padding: 10px 14px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }

        table td {
            padding: 13px 14px;
            border-bottom: 1px solid rgba(255,255,255,0.025);
            color: var(--text-dim);
            vertical-align: middle;
        }

        table tr:last-child td { border-bottom: none; }

        table tbody tr { transition: background 0.15s; }
        table tbody tr:hover td {
            background: rgba(0, 212, 170, 0.03);
            color: var(--text);
        }

        .mono { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--text); }
        .mono-dim { font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-muted); }

        .health-wrap { display: flex; align-items: center; gap: 10px; }

        .health-num {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--accent);
            width: 42px;
            flex-shrink: 0;
        }

        .health-bar {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.06);
            border-radius: 2px;
            overflow: hidden;
            min-width: 70px;
        }

        .health-fill {
            height: 100%;
            border-radius: 2px;
            background: linear-gradient(90deg, var(--accent), #00f5c4);
            box-shadow: 0 0 6px var(--accent-glow);
            transition: width 0.6s ease;
        }

        /* Badges */
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .badge::before {
            content: '';
            width: 5px;
            height: 5px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .badge-online    { background: rgba(0,212,170,.1);  color: var(--accent); border: 1px solid rgba(0,212,170,.2); }
        .badge-online::before { background: var(--accent); box-shadow: 0 0 5px var(--accent); }

        .badge-offline   { background: rgba(100,116,139,.1); color: #64748b;       border: 1px solid rgba(100,116,139,.2); }
        .badge-offline::before { background: #64748b; }

        .badge-pending   { background: rgba(245,158,11,.1); color: var(--amber);  border: 1px solid rgba(245,158,11,.2); }
        .badge-pending::before { background: var(--amber); }

        .badge-running   { background: rgba(0,212,170,.08); color: var(--accent); border: 1px solid rgba(0,212,170,.15); }
        .badge-running::before { background: var(--accent); animation: pulse 1.4s ease-in-out infinite; }

        .badge-completed { background: rgba(59,130,246,.1); color: var(--blue);   border: 1px solid rgba(59,130,246,.2); }
        .badge-completed::before { background: var(--blue); }

        .badge-failed    { background: rgba(239,68,68,.1);  color: var(--red);    border: 1px solid rgba(239,68,68,.2); }
        .badge-failed::before { background: var(--red); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50%       { opacity: 0.4; }
        }

        .status-cell {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .eject-btn {
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(239, 68, 68, 0.35);
            background: rgba(239, 68, 68, 0.08);
            color: #fca5a5;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .eject-btn:hover:not(:disabled) {
            border-color: rgba(239, 68, 68, 0.6);
            background: rgba(239, 68, 68, 0.16);
            color: #fecaca;
        }

        .eject-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .observability-btn {
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(0, 212, 170, 0.35);
            background: rgba(0, 212, 170, 0.08);
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .observability-btn:hover:not(:disabled) {
            border-color: rgba(0, 212, 170, 0.6);
            background: rgba(0, 212, 170, 0.16);
            color: #5ffae0;
        }

        .observability-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .heartbeat-btn {
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(96, 165, 250, 0.35);
            background: rgba(96, 165, 250, 0.08);
            color: #93c5fd;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .heartbeat-btn:hover:not(:disabled) {
            border-color: rgba(96, 165, 250, 0.6);
            background: rgba(96, 165, 250, 0.16);
            color: #bfdbfe;
        }

        .heartbeat-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .empty-row td {
            text-align: center;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 40px;
        }

        /* Form */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }

        @media (max-width: 900px) { .form-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 560px) { .form-grid { grid-template-columns: 1fr; } }

        .form-group { display: flex; flex-direction: column; gap: 6px; }

        .form-group label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 10px 14px;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }

        .form-group select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 34px;
        }

        .form-group textarea {
            min-height: 120px;
            resize: vertical;
            line-height: 1.45;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-dim);
        }

        .form-group input::placeholder { color: var(--text-muted); }
        .form-group select option { background: #111827; }

        .form-footer {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Error banner */
        .error-banner {
            display: none;
            background: rgba(239,68,68,0.08);
            border: 1px solid rgba(239,68,68,0.25);
            border-radius: 8px;
            padding: 12px 18px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--red);
            margin-bottom: 20px;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 28px;
            right: 28px;
            background: var(--surface);
            border: 1px solid var(--border-hover);
            border-radius: 10px;
            padding: 13px 20px;
            font-size: 13px;
            color: var(--text);
            box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 24px var(--accent-glow);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(80px);
            opacity: 0;
            transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .toast.show { transform: translateY(0); opacity: 1; }
        .toast-icon { font-size: 15px; color: var(--accent); }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(7, 11, 18, 0.72);
            backdrop-filter: blur(4px);
            z-index: 1100;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .modal-overlay.open { display: flex; }

        .modal {
            width: min(760px, 100%);
            max-height: 92vh;
            overflow-y: auto;
            background: linear-gradient(170deg, var(--surface) 0%, #0b1220 100%);
            border: 1px solid var(--border-hover);
            border-radius: 14px;
            box-shadow: 0 18px 80px rgba(0, 0, 0, 0.5), 0 0 24px var(--accent-glow);
            padding: 22px;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 16px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 0.01em;
        }

        .modal-subtitle {
            margin-top: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            letter-spacing: 0.05em;
        }

        .modal-close {
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-dim);
            width: 34px;
            height: 34px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--accent);
            border-color: var(--border-hover);
            background: var(--accent-dim);
        }

        .form-group.form-span-3 { grid-column: span 3; }
        @media (max-width: 900px) { .form-group.form-span-3 { grid-column: span 2; } }
        @media (max-width: 560px) { .form-group.form-span-3 { grid-column: span 1; } }

        .form-group.form-span-2 { grid-column: span 2; }
        @media (max-width: 560px) { .form-group.form-span-2 { grid-column: span 1; } }

        .requirements-stack {
            display: grid;
            gap: 12px;
            justify-items: start;
        }

        .requirements-stack > div {
            display: grid;
            grid-template-columns: 180px 120px;
            align-items: center;
            column-gap: 10px;
        }

        .requirements-stack > div > label {
            margin: 0;
        }

        .requirements-stack > div > select {
            width: 120px;
        }

        .task-type-description {
            margin-top: 2px;
            line-height: 1.5;
            color: var(--text-dim);
        }

        .task-type-description strong {
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 10px;
        }

        .inline-hint {
            margin-top: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
        }

        .inline-hint.error { color: var(--red); }
        .inline-hint.success { color: var(--accent); }

        .task-action-cell {
            text-align: right;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        .task-action-group {
            display: inline-flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.18);
            color: #fecaca;
            border: 1px solid rgba(239, 68, 68, 0.4);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.28);
            box-shadow: 0 0 16px rgba(239, 68, 68, 0.35);
        }

        .result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .result-meta {
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px;
        }

        .result-meta-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 6px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .result-meta-value {
            font-size: 14px;
            color: var(--text);
            word-break: break-word;
        }

        .result-payload {
            width: 100%;
            min-height: 220px;
            max-height: 380px;
            overflow: auto;
            margin-top: 14px;
            background: #090f1a;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-dim);
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .result-actions {
            margin-top: 16px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 10px;
        }

        .result-actions-left,
        .result-actions-right {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .heartbeat-info {
            margin-top: 14px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-dim);
        }

        .heartbeat-info p {
            margin: 0 0 12px 0;
            line-height: 1.5;
        }

        .heartbeat-info ul {
            margin: 0 0 12px 0;
            padding-left: 24px;
        }

        .heartbeat-info li {
            margin: 6px 0;
            line-height: 1.5;
        }

        .heartbeat-info code {
            background: rgba(255, 255, 255, 0.05);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        .heartbeat-status-message {
            font-weight: 500;
            padding: 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
        }

        .heartbeat-status-message.success {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .heartbeat-status-message.error {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .heartbeat-status-message p {
            margin: 8px 0;
        }

        .heartbeat-status-message p:first-child {
            font-weight: 600;
            margin-top: 0;
        }

        .heartbeat-status-message p:last-child {
            margin-bottom: 0;
        }

        .heartbeat-tasks {
            margin-top: 14px;
        }

        .heartbeat-tasks-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .heartbeat-task-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .heartbeat-task-id {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-dim);
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .heartbeat-task-type {
            color: var(--text-dim);
            font-size: 11px;
        }

        .heartbeat-exec-badge {
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 4px;
            font-weight: 600;
            letter-spacing: 0.03em;
            white-space: nowrap;
        }

        .heartbeat-exec-badge.exec-assigned {
            background: rgba(148, 163, 184, 0.12);
            color: #94a3b8;
        }

        .heartbeat-exec-badge.exec-in-progress {
            background: rgba(251, 191, 36, 0.12);
            color: #fbbf24;
        }

        .heartbeat-exec-badge.exec-completed {
            background: rgba(74, 222, 128, 0.12);
            color: #4ade80;
        }

        .heartbeat-exec-badge.exec-failed {
            background: rgba(248, 113, 113, 0.12);
            color: #f87171;
        }

        .heartbeat-gateway-hint {
            font-size: 10px;
            color: #60a5fa;
            margin-left: auto;
            white-space: nowrap;
        }

        .heartbeat-ping-log {
            margin-top: 14px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-dim);
        }

        .heartbeat-ping-log-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .heartbeat-ping-entry {
            margin: 4px 0;
            line-height: 1.6;
        }

        .heartbeat-ping-entry.ok {
            color: #4ade80;
        }

        .heartbeat-ping-entry.err {
            color: #f87171;
        }
    </style>
</head>
<body>
<div class="layout">

    <header class="header">
        <div>
            <div class="logo-row">
                <div class="logo-mark">
                    <svg viewBox="0 0 24 24" fill="none" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"/>
                        <line x1="12" y1="22" x2="12" y2="15.5"/>
                        <polyline points="22 8.5 12 15.5 2 8.5"/>
                    </svg>
                </div>
                <h1>Ambient <span>AI</span> VCP</h1>
            </div>
            <div class="subtitle">DECENTRALIZED COMPUTE NETWORK DASHBOARD</div>
            <div class="connect-bar header-connect">
                <label for="api-url">Endpoint</label>
                <input type="text" id="api-url" value="https://ambient-ai-vcp-system.onrender.com" spellcheck="false">
                <button type="button" id="connect-btn" onclick="updateApiUrl()" class="btn">Connect</button>
            </div>
        </div>
        <div class="header-right">
            <div class="live-badge" id="live-badge" aria-live="polite">
                <div class="live-dot"></div>
                <span id="live-label">Live / Disconnected</span>
            </div>
            <div class="refresh-info" id="last-updated">‚Äî</div>
        </div>
    </header>

    <!-- Authentication Section -->
    <div id="auth-section" style="display: none;">
        <div class="section" style="max-width: 500px; margin: 40px auto;">
            <div class="section-header">
                <div class="section-title">üîê Authentication Required</div>
            </div>
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="showAuthTab('login')">Login</button>
                <button class="auth-tab" onclick="showAuthTab('register')">Register</button>
            </div>
            
            <!-- Login Form -->
            <form id="login-form" class="auth-form" style="display: block;" onsubmit="handleLogin(event)">
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="login-username" placeholder="Enter your username" required>
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="login-password" placeholder="Enter your password" required>
                </div>
                <button type="submit" class="btn">Login</button>
            </form>

            <!-- Register Form -->
            <form id="register-form" class="auth-form" style="display: none;" onsubmit="handleRegister(event)">
                <div class="form-group">
                    <label>Username (3-32 characters)</label>
                    <input type="text" id="reg-username" placeholder="Choose a username" required minlength="3" maxlength="32">
                </div>
                <div class="form-group">
                    <label>Password (min 8 characters)</label>
                    <input type="password" id="reg-password" placeholder="Choose a password" required minlength="8">
                </div>
                <button type="submit" class="btn">Register</button>
            </form>
        </div>
    </div>

    <!-- Main Content (requires authentication) -->
    <div id="main-content">
        <div style="text-align: right; padding: 0 20px; margin-bottom: 20px;">
            <span id="user-info" style="color: var(--text-dim); margin-right: 15px;"></span>
            <button onclick="logout()" class="btn btn-ghost" style="font-size: 13px; padding: 6px 14px;">Logout</button>
        </div>

    <div class="error-banner" id="error-banner">‚ö† Unable to reach API ‚Äî check endpoint or network connection</div>

    <div class="stats-grid">
        <div class="stat-card">
            <span class="stat-icon">‚¨°</span>
            <div class="stat-label">Total Nodes</div>
            <div class="stat-value" id="total-nodes">‚Äî</div>
            <div class="stat-sub">Registered in cluster</div>
        </div>
        <div class="stat-card">
            <span class="stat-icon">‚óà</span>
            <div class="stat-label">Healthy Nodes</div>
            <div class="stat-value" id="healthy-nodes">‚Äî</div>
            <div class="stat-sub">Health score ‚â• 70%</div>
        </div>
        <div class="stat-card">
            <span class="stat-icon">‚ü≥</span>
            <div class="stat-label">Total Tasks</div>
            <div class="stat-value" id="total-tasks">‚Äî</div>
            <div class="stat-sub">Submitted to network</div>
        </div>
        <div class="stat-card">
            <span class="stat-icon">‚óé</span>
            <div class="stat-label">Avg Health</div>
            <div class="stat-value" id="avg-health">‚Äî</div>
            <div class="stat-sub">Cluster-wide score</div>
        </div>
    </div>

    <div class="section">
        <div class="section-header">
            <div class="section-title">
                ‚¨° Registered Nodes
                <span class="count-badge" id="nodes-count">0</span>
            </div>
        </div>
        <div class="table-wrap">
            <table>
                <thead>
                    <tr>
                        <th>Node ID</th>
                        <th>Region</th>
                        <th>Type</th>
                        <th>Health Score</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="nodes-table">
                    <tr class="empty-row"><td colspan="5">Fetching nodes...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="section">
        <div class="section-header">
            <div class="section-title">
                ‚ü≥ Recent Tasks
                <span class="count-badge" id="tasks-count">0</span>
            </div>
            <button type="button" class="btn" id="open-task-modal-btn">+ Submit Task</button>
        </div>
        <div class="table-wrap">
            <table>
                <thead>
                    <tr>
                        <th>Task ID</th>
                        <th>Type</th>
                        <th>Status</th>
                        <th>Progress (AI ETA)</th>
                        <th>Assigned Nodes</th>
                        <th>Created At</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="tasks-table">
                    <tr class="empty-row"><td colspan="7">Fetching tasks...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="section">
        <div class="section-header">
            <div class="section-title">+ Register New Node</div>
        </div>
        <form id="register-node-form">
            <div class="form-grid">
                <div class="form-group">
                    <label>Node ID</label>
                    <input type="text" id="node-id" placeholder="e.g. node-001" required>
                </div>
                <div class="form-group">
                    <label>Region</label>
                    <select id="region" required>
                        <option value="us-west">US West</option>
                        <option value="us-east">US East</option>
                        <option value="eu-central">EU Central</option>
                        <option value="ap-southeast">AP Southeast</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Node Type</label>
                    <select id="node-type" required>
                        <option value="any">Any (Universal)</option>
                        <option value="compute">Compute</option>
                        <option value="gateway">Gateway</option>
                        <option value="storage">Storage</option>
                        <option value="validator">Validator</option>
                        <option value="open_internet">Open Internet</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Bandwidth (Mbps)</label>
                    <input type="number" id="bandwidth" value="100" min="1" required>
                </div>
                <div class="form-group">
                    <label>CPU Cores</label>
                    <input type="number" id="cpu-cores" value="4" min="1" required>
                </div>
                <div class="form-group">
                    <label>Memory (GB)</label>
                    <input type="number" id="memory" value="8" min="1" required>
                </div>
            </div>
            <div class="form-footer">
                <button type="submit" class="btn">Register Node</button>
                <button type="reset" class="btn btn-ghost">Clear</button>
            </div>
        </form>
    </div>

    </div> <!-- Close main-content -->

</div> <!-- Close layout -->

<!-- Footer -->
<div style="position: relative; z-index: 1; max-width: 1440px; margin: 0 auto; padding: 32px 24px; text-align: center;">
    <div style="border-top: 1px solid var(--border); padding-top: 24px; display: flex; justify-content: center; align-items: center; gap: 24px; flex-wrap: wrap;">
        <a href="https://github.com/dfeen87/Ambient-AI-VCP-System" target="_blank" rel="noopener noreferrer" style="display: flex; align-items: center; gap: 8px; color: var(--text-dim); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 12px; transition: color 0.2s;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.7;">
                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
            GitHub Repository
        </a>
        <a href="/swagger-ui" style="display: flex; align-items: center; gap: 8px; color: var(--text-dim); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 12px; transition: color 0.2s;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.7;">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
            API Documentation
        </a>
        <a href="/api-docs/openapi.json" target="_blank" style="display: flex; align-items: center; gap: 8px; color: var(--text-dim); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 12px; transition: color 0.2s;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.7;">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="2" y1="12" x2="22" y2="12"></line>
                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
            </svg>
            OpenAPI JSON
        </a>
    </div>
    <div style="margin-top: 16px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-muted); opacity: 0.6;">
        Ambient AI VCP System v1.0.0 ‚Ä¢ Production-Ready Verifiable Computation Protocol
    </div>
</div>

<style>
    /* Footer link hover effects */
    div a:hover {
        color: var(--accent) !important;
    }
    div a:hover svg {
        opacity: 1 !important;
    }
</style>

<div class="toast" id="toast">
    <span class="toast-icon" id="toast-icon">‚úì</span>
    <span id="toast-msg">Node registered</span>
</div>

<div class="modal-overlay" id="task-modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="task-modal-title">
        <div class="modal-header">
            <div>
                <div class="modal-title" id="task-modal-title">Submit New Task</div>
                <div class="modal-subtitle">Stored via /api/v1/tasks and immediately reflected in your database-backed tasks list.</div>
            </div>
            <button type="button" class="modal-close" id="close-task-modal-btn" aria-label="Close task modal">√ó</button>
        </div>

        <form id="submit-task-form" novalidate>
            <div class="form-grid">
                <div class="form-group">
                    <label>Task Type</label>
                    <select id="task-type" required>
                        <option value="computation">Computation</option>
                        <option value="federated_learning">Federated Learning</option>
                        <option value="zk_proof">ZK Proof</option>
                        <option value="wasm_execution">WASM Execution</option>
                        <option value="connect_only">Connect Only</option>
                    </select>
                    <div class="inline-hint" id="task-type-hint">Smart defaults will update based on task type.</div>
                </div>

                <div class="form-group">
                    <label>Min Nodes</label>
                    <input type="number" id="task-min-nodes" min="1" max="1000" value="1" required>
                    <div class="inline-hint" id="min-nodes-hint">Must be between 1 and 1000.</div>
                </div>

                <div class="form-group">
                    <label>Max Execution (sec)</label>
                    <input type="number" id="task-max-exec" min="1" max="3600" value="300" required>
                    <div class="inline-hint" id="max-exec-hint">Must be between 1 and 3600.</div>
                </div>

                <div class="form-group form-span-2">
                    <label>Selected Task Meaning</label>
                    <div class="inline-hint task-type-description" id="task-type-description">Choose a task type to see a quick explanation of what it does.</div>
                </div>

                <div class="form-group">
                    <label>Task Requirements</label>
                    <div class="requirements-stack">
                        <div>
                            <label for="task-require-gpu">Require GPU</label>
                            <select id="task-require-gpu" required>
                                <option value="false" selected>No</option>
                                <option value="true">Yes</option>
                            </select>
                        </div>
                        <div>
                            <label for="task-require-proof">Require Proof</label>
                            <select id="task-require-proof" required>
                                <option value="false" selected>No</option>
                                <option value="true">Yes</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="form-group form-span-3">
                    <label>Inputs (JSON)</label>
                    <textarea id="task-inputs" placeholder="Enter JSON or plain text task inputs" required></textarea>
                    <div style="display: flex; gap: 12px; margin-top: 10px; margin-bottom: 8px;">
                        <button type="button" class="btn btn-ghost" id="convert-inputs-btn">Convert Plain Text ‚Üí JSON</button>
                    </div>
                    <div class="inline-hint" id="task-inputs-hint">You can paste JSON or plain text; for connect_only, use strict JSON schema fields only.</div>
                </div>
            </div>

            <div class="form-footer">
                <button type="button" class="btn" id="submit-task-btn">Submit Task</button>
                <button type="button" class="btn btn-ghost" id="cancel-task-modal-btn">Cancel</button>
            </div>
        </form>
    </div>
</div>

<div class="modal-overlay" id="task-result-modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="task-result-modal-title">
        <div class="modal-header">
            <div>
                <div class="modal-title" id="task-result-modal-title">Completed Task Result</div>
                <div class="modal-subtitle">View, download, or send this completed task result by email.</div>
            </div>
            <button type="button" class="modal-close" id="close-task-result-modal-btn" aria-label="Close task result modal">√ó</button>
        </div>

        <div class="result-grid">
            <div class="result-meta">
                <div class="result-meta-label">Task ID</div>
                <div class="result-meta-value mono-dim" id="result-task-id">‚Äî</div>
            </div>
            <div class="result-meta">
                <div class="result-meta-label">Task Type</div>
                <div class="result-meta-value" id="result-task-type">‚Äî</div>
            </div>
        </div>

        <pre class="result-payload" id="result-task-payload">No result available.</pre>

        <div class="result-actions">
            <div class="result-actions-left">
                <button type="button" class="btn" id="download-task-result-btn">Download JSON</button>
            </div>
            <div class="result-actions-right">
                <button type="button" class="btn btn-ghost" id="send-task-result-email-btn">Send to Email</button>
                <button type="button" class="btn btn-ghost" id="close-task-result-modal-footer-btn">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Observability Modal -->
<div class="modal-overlay" id="observability-modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="observability-modal-title">
        <div class="modal-header">
            <div>
                <div class="modal-title" id="observability-modal-title">Node Observability</div>
                <div class="modal-subtitle">Read-only local observability data from your node.</div>
            </div>
            <button type="button" class="modal-close" id="close-observability-modal-btn" aria-label="Close observability modal">√ó</button>
        </div>

        <div class="result-grid">
            <div class="result-meta">
                <div class="result-meta-label">Node ID</div>
                <div class="result-meta-value mono-dim" id="obs-node-id">‚Äî</div>
            </div>
            <div class="result-meta">
                <div class="result-meta-label">Observability Port</div>
                <div class="result-meta-value" id="obs-port">‚Äî</div>
            </div>
        </div>

        <pre class="result-payload" id="obs-data-payload">Loading observability data...</pre>

        <div class="result-actions">
            <div class="result-actions-left">
                <button type="button" class="btn" id="refresh-observability-btn">Refresh</button>
            </div>
            <div class="result-actions-right">
                <button type="button" class="btn btn-ghost" id="close-observability-modal-footer-btn">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Heartbeat Modal -->
<div class="modal-overlay" id="heartbeat-modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="heartbeat-modal-title">
        <div class="modal-header">
            <div>
                <div class="modal-title" id="heartbeat-modal-title">Send Node Heartbeat</div>
                <div class="modal-subtitle">Update the heartbeat timestamp for your node.</div>
            </div>
            <button type="button" class="modal-close" id="close-heartbeat-modal-btn" aria-label="Close heartbeat modal">√ó</button>
        </div>

        <div class="result-grid">
            <div class="result-meta">
                <div class="result-meta-label">Node ID</div>
                <div class="result-meta-value mono-dim" id="heartbeat-node-id">‚Äî</div>
            </div>
            <div class="result-meta">
                <div class="result-meta-label">Status</div>
                <div class="result-meta-value" id="heartbeat-node-status">‚Äî</div>
            </div>
            <div class="result-meta">
                <div class="result-meta-label">Health Score</div>
                <div class="result-meta-value" id="heartbeat-node-health">‚Äî</div>
            </div>
        </div>

        <div class="heartbeat-info">
            <p>Sending a heartbeat will:</p>
            <ul>
                <li>Update the <code>last_heartbeat</code> timestamp to the current time</li>
                <li>Advance any <code>assigned</code> tasks to <code>in_progress</code> status</li>
                <li>Trigger automatic assignment of any pending tasks you are eligible for</li>
                <li>Prevent your node from being marked offline by the health sweep</li>
            </ul>
            <div id="heartbeat-message" class="heartbeat-status-message" role="status" aria-live="polite" hidden></div>
        </div>

        <div class="heartbeat-tasks" id="heartbeat-tasks-section" hidden>
            <div class="heartbeat-tasks-title">Active Tasks</div>
            <div id="heartbeat-tasks-list"></div>
        </div>

        <div class="heartbeat-ping-log" id="heartbeat-ping-log" hidden>
            <div class="heartbeat-ping-log-title">Activity Log</div>
            <div id="heartbeat-ping-entries"></div>
        </div>

        <div class="result-actions">
            <div class="result-actions-left">
                <button type="button" class="btn" id="send-heartbeat-btn">Send Heartbeat</button>
            </div>
            <div class="result-actions-right">
                <button type="button" class="btn btn-ghost" id="close-heartbeat-modal-footer-btn">Cancel</button>
            </div>
        </div>
    </div>
</div>

<script>
    const DEFAULT_API_BASE_URL = 'https://ambient-ai-vcp-system.onrender.com';
    let apiBaseUrl = localStorage.getItem('vcp_api_base_url') || DEFAULT_API_BASE_URL;
    let authToken = localStorage.getItem('vcp_auth_token');
    let currentUser = localStorage.getItem('vcp_username');
    let currentUserId = parseUserIdFromToken(authToken);
    let isApiConnected = false;
    let lastRelayConnection = null;
    let nodes = [];
    let tasks = [];
    const taskProgressMemory = new Map();
    const TASK_COMPLETION_LOCKS_STORAGE_KEY = 'vcp_task_completion_locks_v1';
    let taskCompletionLocks = loadTaskCompletionLocks();
    let selectedCompletedTask = null;

    const taskDurationByTypeSec = {
        // Keep computation ETA optimistic so lightweight jobs (e.g. simple arithmetic)
        // don't show multi-minute projections.
        computation: 45,
        federated_learning: 900,
        zk_proof: 600,
        wasm_execution: 450,
        connect_only: 120,
    };


    function parseUserIdFromToken(token) {
        if (!token) return null;
        try {
            const payloadBase64 = token.split('.')[1];
            if (!payloadBase64) return null;
            const normalized = payloadBase64.replace(/-/g, '+').replace(/_/g, '/');
            const padded = normalized + '='.repeat((4 - normalized.length % 4) % 4);
            const payload = JSON.parse(atob(padded));
            return payload.sub || null;
        } catch (_err) {
            return null;
        }
    }

    function loadTaskCompletionLocks() {
        try {
            const parsed = JSON.parse(localStorage.getItem(TASK_COMPLETION_LOCKS_STORAGE_KEY) || '{}');
            return parsed && typeof parsed === 'object' ? parsed : {};
        } catch (_err) {
            return {};
        }
    }

    function saveTaskCompletionLocks() {
        localStorage.setItem(TASK_COMPLETION_LOCKS_STORAGE_KEY, JSON.stringify(taskCompletionLocks));
    }

    function getTaskCompletionScope() {
        return `${apiBaseUrl}::${currentUserId || currentUser || 'anonymous'}`;
    }

    function isTaskCompletionLocked(taskId) {
        const key = `${getTaskCompletionScope()}::${taskId}`;
        return taskCompletionLocks[key] === true;
    }

    function lockTaskCompletion(taskId) {
        const key = `${getTaskCompletionScope()}::${taskId}`;
        if (taskCompletionLocks[key] !== true) {
            taskCompletionLocks[key] = true;
            saveTaskCompletionLocks();
        }
    }

    function getStatusBadgeClass(status) {
        if (status === 'online')    return 'badge-online';
        if (status === 'offline')   return 'badge-offline';
        if (status === 'running')   return 'badge-running';
        if (status === 'completed') return 'badge-completed';
        if (status === 'failed')    return 'badge-failed';
        if (status === 'rejected')  return 'badge-failed';
        return 'badge-pending';
    }

    function escapeHtml(text) {
        return String(text)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    // Check if user is logged in on page load
    function checkAuth() {
        const authSection = document.getElementById('auth-section');
        const mainContent = document.getElementById('main-content');
        const userInfo = document.getElementById('user-info');
        
        if (authToken && currentUser) {
            authSection.style.display = 'none';
            mainContent.style.display = 'block';
            userInfo.textContent = `Logged in as: ${currentUser}`;
            fetchData();
        } else {
            authSection.style.display = 'block';
            mainContent.style.display = 'none';
        }
    }

    function logout() {
        localStorage.removeItem('vcp_auth_token');
        localStorage.removeItem('vcp_username');
        authToken = null;
        currentUser = null;
        currentUserId = null;
        isApiConnected = false;
        setConnectionStatus(false);
        taskCompletionLocks = loadTaskCompletionLocks();
        checkAuth();
    }

    async function handleLogin(e) {
        e.preventDefault();
        const username = document.getElementById('login-username').value;
        const password = document.getElementById('login-password').value;
        const btn = e.target.querySelector('[type="submit"]');
        
        btn.textContent = 'Logging in...';
        btn.disabled = true;

        try {
            const res = await fetch(`${apiBaseUrl}/api/v1/auth/login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password }),
            });

            if (res.ok) {
                const data = await res.json();
                authToken = data.access_token;
                currentUser = username;
                localStorage.setItem('vcp_auth_token', authToken);
                localStorage.setItem('vcp_username', username);
                currentUserId = parseUserIdFromToken(authToken);
                taskCompletionLocks = loadTaskCompletionLocks();
                showToast('Login successful!');
                checkAuth();
            } else {
                const err = await res.json();
                showToast(err.message || 'Login failed', true);
            }
        } catch (err) {
            showToast('Network error: ' + err.message, true);
        } finally {
            btn.textContent = 'Login';
            btn.disabled = false;
        }
    }

    async function handleRegister(e) {
        e.preventDefault();
        const username = document.getElementById('reg-username').value;
        const password = document.getElementById('reg-password').value;
        const btn = e.target.querySelector('[type="submit"]');
        
        btn.textContent = 'Registering...';
        btn.disabled = true;

        try {
            const res = await fetch(`${apiBaseUrl}/api/v1/auth/register`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password }),
            });

            if (res.ok) {
                const data = await res.json();
                showToast(`Account created! API Key: ${data.api_key} (save this!)`);
                // Auto-login after registration
                setTimeout(() => {
                    document.getElementById('login-username').value = username;
                    document.getElementById('login-password').value = password;
                    document.getElementById('login-form').dispatchEvent(new Event('submit'));
                }, 2000);
            } else {
                const err = await res.json();
                showToast(err.message || 'Registration failed', true);
            }
        } catch (err) {
            showToast('Network error: ' + err.message, true);
        } finally {
            btn.textContent = 'Register';
            btn.disabled = false;
        }
    }

    function getAuthHeaders() {
        return authToken ? {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
        } : {
            'Content-Type': 'application/json'
        };
    }

    function normalizeApiBaseUrl(url) {
        const trimmed = (url || '').trim().replace(/\/$/, '');
        return /^https?:\/\//i.test(trimmed) ? trimmed : `https://${trimmed}`;
    }

    function setConnectionStatus(isConnected) {
        isApiConnected = isConnected;
        const liveBadge = document.getElementById('live-badge');
        const liveLabel = document.getElementById('live-label');

        if (!liveBadge || !liveLabel) {
            return;
        }

        const relayHint = buildRelayConnectionHint(isConnected);
        const statusLabel = `API / ${isConnected ? 'Connected' : 'Disconnected'}${relayHint}`;
        liveLabel.textContent = statusLabel;
        liveBadge.classList.toggle('connected', isConnected);
    }

    function buildRelayConnectionHint(isConnected) {
        if (!isConnected || !lastRelayConnection) {
            return '';
        }

        const nodeList = lastRelayConnection.nodeIds.join(', ');
        return ` ‚Ä¢ Relay node ${nodeList}`;
    }

    function refreshRelayConnectionSnapshot(tasks) {
        const activeConnectTask = tasks.find(task =>
            task.task_type === 'connect_only' && task.assigned_nodes && task.assigned_nodes.length > 0
        );

        if (!activeConnectTask) {
            lastRelayConnection = null;
            return;
        }

        lastRelayConnection = {
            taskId: activeConnectTask.task_id,
            nodeIds: [...activeConnectTask.assigned_nodes],
            updatedAtMs: Date.now(),
        };
    }

    function requireApiConnection(actionLabel = 'perform this action') {
        if (isApiConnected) {
            return true;
        }

        showToast(`Please connect to the API first to ${actionLabel}.`, true);
        return false;
    }

    async function updateApiUrl() {
        const connectBtn = document.getElementById('connect-btn');
        const inputEl = document.getElementById('api-url');
        const candidateUrl = normalizeApiBaseUrl(inputEl.value);

        if (!candidateUrl || candidateUrl === 'https://') {
            showToast('Please provide a valid API endpoint URL', true);
            return;
        }

        const previousUrl = apiBaseUrl;
        connectBtn.disabled = true;
        connectBtn.textContent = 'Connecting...';

        try {
            const probeRes = await fetch(`${candidateUrl}/api/v1/cluster/stats`, {
                headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {},
            });

            if (!probeRes.ok && probeRes.status !== 401 && probeRes.status !== 403) {
                throw new Error(`endpoint responded with HTTP ${probeRes.status}`);
            }

            apiBaseUrl = candidateUrl;
            inputEl.value = candidateUrl;
            localStorage.setItem('vcp_api_base_url', candidateUrl);
            setConnectionStatus(true);
            showToast(`Connected to ${candidateUrl}`);

            if (authToken) {
                await fetchData();
            }
        } catch (err) {
            apiBaseUrl = previousUrl;
            setConnectionStatus(false);
            showToast(`Unable to connect: ${err.message}`, true);
        } finally {
            connectBtn.disabled = false;
            connectBtn.textContent = 'Connect';
        }
    }

    function showToast(msg, isError = false) {
        const toast = document.getElementById('toast');
        document.getElementById('toast-msg').textContent = msg;
        document.getElementById('toast-icon').textContent = isError ? '‚úï' : '‚úì';
        document.getElementById('toast-icon').style.color = isError ? 'var(--red)' : 'var(--accent)';
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3500);
    }

    function openTaskModal() {
        const modal = document.getElementById('task-modal-overlay');
        modal.classList.add('open');
        modal.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
    }

    function closeTaskModal() {
        const modal = document.getElementById('task-modal-overlay');
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = '';
    }

    function updateTaskDefaults() {
        const taskType = document.getElementById('task-type').value;
        const requireProofEl = document.getElementById('task-require-proof');
        const requireGpuEl = document.getElementById('task-require-gpu');
        const maxExecEl = document.getElementById('task-max-exec');
        const minNodesEl = document.getElementById('task-min-nodes');
        const inputsEl = document.getElementById('task-inputs');
        const hintEl = document.getElementById('task-type-hint');
        const descriptionEl = document.getElementById('task-type-description');
        const convertInputsBtn = document.getElementById('convert-inputs-btn');

        const taskPresets = {
            computation: {
                minNodes: 1,
                maxExec: 300,
                requireGpu: 'false',
                requireProof: 'false',
                inputs: '',
                hint: 'Computation preset applied. You can still change any field before submit.',
                description: '<strong>Computation:</strong> Runs a general-purpose compute job on available nodes with flexible inputs.'
            },
            federated_learning: {
                minNodes: 3,
                maxExec: 900,
                requireGpu: 'true',
                requireProof: 'false',
                inputs: '',
                hint: 'Federated Learning preset applied (GPU + longer runtime). Fields remain editable.',
                description: '<strong>Federated Learning:</strong> Trains shared AI models across multiple nodes while data stays decentralized.'
            },
            zk_proof: {
                minNodes: 1,
                maxExec: 600,
                requireGpu: 'false',
                requireProof: 'true',
                inputs: '',
                hint: 'ZK Proof preset applied (proof required). Fields remain editable.',
                description: '<strong>ZK Proof:</strong> Generates verifiable cryptographic proof that a computation was executed correctly.'
            },
            wasm_execution: {
                minNodes: 1,
                maxExec: 450,
                requireGpu: 'false',
                requireProof: 'false',
                inputs: '',
                hint: 'WASM preset applied. Keep inputs compact; you can adjust everything.',
                description: '<strong>WASM Execution:</strong> Executes WebAssembly modules in a sandboxed runtime across the network.'
            },
            connect_only: {
                minNodes: 1,
                maxExec: 300,
                requireGpu: 'false',
                requireProof: 'false',
                inputs: JSON.stringify({
                    session_id: 'sess_123',
                    requester_id: 'user_abc',
                    duration_seconds: 300,
                    bandwidth_limit_mbps: 20,
                    egress_profile: 'allowlist_domains',
                    destination_policy_id: 'policy_web_basic_v1'
                }, null, 2),
                hint: 'Connect Only preset applied. JSON schema is strict and free-form task descriptions are not allowed.',
                description: '<strong>Connect Only:</strong> Creates a secure connection session with strict policy-driven JSON fields and no compute workload.'
            }
        };

        const preset = taskPresets[taskType] || taskPresets.computation;
        minNodesEl.value = preset.minNodes;
        maxExecEl.value = preset.maxExec;
        requireGpuEl.value = preset.requireGpu;
        requireProofEl.value = preset.requireProof;
        inputsEl.value = preset.inputs;
        hintEl.textContent = preset.hint;
        descriptionEl.innerHTML = preset.description;

        const isConnectOnly = taskType === 'connect_only';
        inputsEl.readOnly = isConnectOnly;
        convertInputsBtn.disabled = isConnectOnly;
        convertInputsBtn.title = isConnectOnly
            ? 'Connect Only payload is generated by policy and cannot be edited in this form.'
            : '';

        validateTaskForm();
    }

    function validateTaskForm() {
        const taskType = document.getElementById('task-type').value;
        const minNodes = parseInt(document.getElementById('task-min-nodes').value, 10);
        const maxExec = parseInt(document.getElementById('task-max-exec').value, 10);
        const inputsRaw = document.getElementById('task-inputs').value.trim();

        const minNodesHint = document.getElementById('min-nodes-hint');
        const maxExecHint = document.getElementById('max-exec-hint');
        const inputsHint = document.getElementById('task-inputs-hint');

        let isValid = true;

        if (Number.isNaN(minNodes) || minNodes < 1 || minNodes > 1000) {
            minNodesHint.textContent = 'Invalid: min_nodes must be between 1 and 1000.';
            minNodesHint.className = 'inline-hint error';
            isValid = false;
        } else {
            minNodesHint.textContent = 'Looks good.';
            minNodesHint.className = 'inline-hint success';
        }

        if (Number.isNaN(maxExec) || maxExec < 1 || maxExec > 3600) {
            maxExecHint.textContent = 'Invalid: max_execution_time_sec must be between 1 and 3600.';
            maxExecHint.className = 'inline-hint error';
            isValid = false;
        } else {
            maxExecHint.textContent = 'Looks good.';
            maxExecHint.className = 'inline-hint success';
        }

        const parsedInputs = parseTaskInputsFlexible(inputsRaw);
        const strictJsonState = classifyJsonInput(inputsRaw);

        if (parsedInputs === null) {
            inputsHint.textContent = 'Inputs are required. Add JSON or plain text before submitting.';
            inputsHint.className = 'inline-hint error';
            isValid = false;
        } else if (taskType === 'connect_only') {
            const allowedKeys = ['session_id', 'requester_id', 'duration_seconds', 'bandwidth_limit_mbps', 'egress_profile', 'destination_policy_id'];

            if (strictJsonState !== 'valid' || typeof parsedInputs !== 'object' || parsedInputs === null || Array.isArray(parsedInputs)) {
                inputsHint.textContent = 'connect_only requires a valid JSON object.';
                inputsHint.className = 'inline-hint error';
                isValid = false;
            } else {
                const keys = Object.keys(parsedInputs);
                const unknown = keys.find((k) => !allowedKeys.includes(k));
                const missing = allowedKeys.filter((k) => !(k in parsedInputs));

                if (unknown) {
                    inputsHint.textContent = `connect_only does not allow key: ${unknown}`;
                    inputsHint.className = 'inline-hint error';
                    isValid = false;
                } else if (missing.length > 0) {
                    inputsHint.textContent = `connect_only missing required fields: ${missing.join(', ')}`;
                    inputsHint.className = 'inline-hint error';
                    isValid = false;
                } else {
                    inputsHint.textContent = 'connect_only schema looks valid.';
                    inputsHint.className = 'inline-hint success';
                }
            }

            if (minNodes !== 1) {
                minNodesHint.textContent = 'connect_only requires min_nodes = 1.';
                minNodesHint.className = 'inline-hint error';
                isValid = false;
            }
        } else if (strictJsonState === 'valid') {
            inputsHint.textContent = 'Valid JSON payload.';
            inputsHint.className = 'inline-hint success';
        } else if (strictJsonState === 'invalid') {
            inputsHint.textContent = 'JSON-looking input is invalid. Fix the JSON syntax or use plain text, then click convert.';
            inputsHint.className = 'inline-hint error';
            isValid = false;
        } else {
            inputsHint.textContent = 'Plain text detected. Click "Convert Plain Text ‚Üí JSON" before submit.';
            inputsHint.className = 'inline-hint success';
        }

        return isValid;
    }

    function looksLikeJson(raw) {
        return /^[\[{]/.test(raw.trim());
    }

    function classifyJsonInput(rawInputs) {
        const trimmed = (rawInputs || '').trim();
        if (!trimmed || !looksLikeJson(trimmed)) {
            return 'not-json';
        }

        try {
            JSON.parse(trimmed);
            return 'valid';
        } catch (_err) {
            return 'invalid';
        }
    }

    function parseTaskInputsFlexible(rawInputs) {
        const trimmed = (rawInputs || '').trim();
        if (!trimmed) {
            return null;
        }

        try {
            return JSON.parse(trimmed);
        } catch (_err) {
            return { prompt: trimmed, description: '' };
        }
    }

    function convertPlainTextInputsToJson() {
        if (document.getElementById('task-type').value === 'connect_only') {
            const inputsHint = document.getElementById('task-inputs-hint');
            inputsHint.textContent = 'connect_only payload is read-only in the UI. Submit as shown.';
            inputsHint.className = 'inline-hint success';
            return;
        }

        const inputsEl = document.getElementById('task-inputs');
        const inputsHint = document.getElementById('task-inputs-hint');
        const raw = (inputsEl.value || '').trim();

        if (!raw) {
            inputsHint.textContent = 'Nothing to convert. Enter plain text first.';
            inputsHint.className = 'inline-hint error';
            return;
        }

        const jsonState = classifyJsonInput(raw);
        if (jsonState === 'valid') {
            inputsHint.textContent = 'Already valid JSON payload.';
            inputsHint.className = 'inline-hint success';
            return;
        }

        if (jsonState === 'invalid') {
            inputsHint.textContent = 'Cannot convert because this starts like JSON but has invalid syntax. Fix it or use plain text only.';
            inputsHint.className = 'inline-hint error';
            return;
        }

        const converted = {
            prompt: raw,
            description: '',
        };
        inputsEl.value = JSON.stringify(converted, null, 2);
        inputsHint.textContent = 'Converted plain text to JSON for node analysis. Description left blank.';
        inputsHint.className = 'inline-hint success';
    }

    function animateValue(el, end) {
        if (end === null || end === undefined || el.textContent === '‚Äî' && isNaN(end)) {
            el.textContent = '‚Äî'; return;
        }
        const isFloat = typeof end === 'number' && !Number.isInteger(end);
        const target = parseFloat(end);
        if (isNaN(target)) { el.textContent = end; return; }
        const prev = parseFloat(el.textContent) || 0;
        const duration = 700;
        const t0 = performance.now();
        const tick = (now) => {
            const p = Math.min((now - t0) / duration, 1);
            const ease = 1 - Math.pow(1 - p, 3);
            el.textContent = isFloat
                ? (prev + (target - prev) * ease).toFixed(1)
                : Math.round(prev + (target - prev) * ease);
            if (p < 1) requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
    }

    async function fetchData() {
        if (!isApiConnected) {
            return;
        }

        const errorEl = document.getElementById('error-banner');
        try {
            const authHeaders = authToken ? {
                'Authorization': `Bearer ${authToken}`
            } : {};

            const [statsRes, nodesRes, tasksRes] = await Promise.all([
                fetch(`${apiBaseUrl}/api/v1/cluster/stats`, { headers: authHeaders }),
                fetch(`${apiBaseUrl}/api/v1/nodes`, { headers: authHeaders }),
                fetch(`${apiBaseUrl}/api/v1/tasks`, { headers: authHeaders }),
            ]);

            if (statsRes.ok) {
                const s = await statsRes.json();
                animateValue(document.getElementById('total-nodes'), s.total_nodes);
                animateValue(document.getElementById('healthy-nodes'), s.healthy_nodes);
                animateValue(document.getElementById('total-tasks'), s.total_tasks);
                animateValue(document.getElementById('avg-health'), s.avg_health_score);
            }

            if (nodesRes.ok) {
                nodes = await nodesRes.json();
                renderNodes(nodes);
                document.getElementById('nodes-count').textContent = nodes.length;
            }

            if (tasksRes.ok) {
                tasks = await tasksRes.json();
                refreshRelayConnectionSnapshot(tasks);
                renderTasks(tasks);
                document.getElementById('tasks-count').textContent = tasks.length;

                // If the heartbeat modal is open, refresh its active-tasks section so
                // newly-assigned tasks appear without requiring the user to reopen the modal.
                // The node ID is stored as data-node-id on the send button when the modal opens.
                const heartbeatOverlay = document.getElementById('heartbeat-modal-overlay');
                if (heartbeatOverlay && heartbeatOverlay.classList.contains('open')) {
                    const currentNodeId = document.getElementById('send-heartbeat-btn').getAttribute('data-node-id');
                    if (currentNodeId) {
                        renderHeartbeatTasks(currentNodeId);
                    }
                }
            }

            errorEl.style.display = 'none';
            setConnectionStatus(true);
            document.getElementById('last-updated').textContent =
                'Updated ' + new Date().toLocaleTimeString();

        } catch (err) {
            console.error(err);
            errorEl.style.display = 'block';
            setConnectionStatus(false);
        }
    }

    async function handleEjectNode(nodeId, buttonEl) {
        if (!requireApiConnection('eject nodes')) {
            return;
        }

        if (!authToken) {
            showToast('Please login to eject nodes', true);
            return;
        }

        if (!confirm(`Eject node ${nodeId}?`)) {
            return;
        }

        const originalText = buttonEl.textContent;
        buttonEl.textContent = 'Ejecting...';
        buttonEl.disabled = true;

        try {
            const res = await fetch(`${apiBaseUrl}/api/v1/nodes/${encodeURIComponent(nodeId)}/reject`, {
                method: 'POST',
                headers: getAuthHeaders(),
            });

            if (res.ok) {
                showToast(`Node ${nodeId} ejected successfully`);
                await fetchData();
            } else {
                const err = await res.json();
                showToast(err.message || 'Failed to eject node', true);
            }
        } catch (err) {
            showToast('Network error: ' + err.message, true);
        } finally {
            buttonEl.textContent = originalText;
            buttonEl.disabled = false;
        }
    }

    async function handleHeartbeat(nodeId, buttonEl) {
        if (!requireApiConnection('send heartbeat')) {
            return;
        }

        if (!authToken) {
            showToast('Please login to send heartbeat', true);
            return;
        }

        // Refresh nodes and tasks so the modal shows up-to-date active tasks
        await fetchData();

        // Find the node data to get status
        const node = nodes.find(n => n.node_id === nodeId);
        const nodeStatus = node ? node.status : 'unknown';

        // Open the modal
        await openHeartbeatModal(nodeId, nodeStatus);
    }

    async function handleViewObservability(nodeId, port) {
        // Open the modal
        openObservabilityModal(nodeId, port);
        
        // Fetch the observability data
        await fetchObservabilityData(nodeId, port);
    }

    function openObservabilityModal(nodeId, port) {
        document.getElementById('obs-node-id').textContent = nodeId;
        document.getElementById('obs-port').textContent = port || 'Not configured';
        document.getElementById('obs-data-payload').textContent = 'Loading observability data...';
        document.getElementById('observability-modal-overlay').classList.add('open');
        document.getElementById('observability-modal-overlay').setAttribute('aria-hidden', 'false');
    }

    function closeObservabilityModal() {
        document.getElementById('observability-modal-overlay').classList.remove('open');
        document.getElementById('observability-modal-overlay').setAttribute('aria-hidden', 'true');
    }

    async function fetchObservabilityData(nodeId, port) {
        const payloadEl = document.getElementById('obs-data-payload');
        
        if (!port) {
            payloadEl.textContent = 'No observability port configured for this node.\n\nTo enable observability, register your node with the observability_port parameter.';
            return;
        }

        try {
            payloadEl.textContent = 'Fetching data from http://127.0.0.1:' + port + '/node/status ...';
            
            // Fetch from local observability endpoint (127.0.0.1 only)
            // NOTE: This will only work when the UI is accessed from the same machine as the node
            // due to same-origin policy and localhost binding.
            const response = await fetch(`http://127.0.0.1:${port}/node/status`);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            payloadEl.textContent = JSON.stringify(data, null, 2);
        } catch (err) {
            payloadEl.textContent = `Error fetching observability data:\n\n${err.message}\n\nNote: The observability endpoint is ONLY accessible from the local machine (127.0.0.1) where the node is running.\n\nCommon issues:\n1. This UI must be accessed from the SAME machine as the node (not remotely)\n2. The node must be running with observability enabled on port ${port}\n3. CORS policies prevent cross-origin requests to localhost from remote origins\n4. Some browsers block localhost requests when the page is served over HTTPS\n\nIf you're running the node on this machine, ensure:\n- The node is running: check with 'curl http://127.0.0.1:${port}/node/status'\n- The observability port ${port} is correct`;
        }
    }

    // renderHeartbeatTasks ‚Äî show execution_status badge and gateway hint per task.
    // freshTasks: optional array from the heartbeat response (contains execution_status).
    // Falls back to filtering the global `tasks` array when freshTasks is not supplied.
    function renderHeartbeatTasks(nodeId, freshTasks) {
        const tasksSection = document.getElementById('heartbeat-tasks-section');
        const tasksList = document.getElementById('heartbeat-tasks-list');
        tasksList.textContent = '';

        // Build the display list from the fresh response when available, otherwise
        // fall back to the globally-cached tasks filtered to this node.
        let displayTasks;
        if (Array.isArray(freshTasks)) {
            displayTasks = freshTasks.map(ft => ({
                task_id: ft.task_id,
                task_type: ft.task_type,
                execution_status: ft.execution_status || 'assigned',
                status: 'running',
            }));
        } else {
            displayTasks = (typeof tasks !== 'undefined' ? tasks : [])
                .filter(t => Array.isArray(t.assigned_nodes) && t.assigned_nodes.includes(nodeId)
                          && t.status !== 'completed' && t.status !== 'failed')
                .map(t => ({ task_id: t.task_id, task_type: t.task_type, status: t.status, execution_status: null }));
        }

        if (displayTasks.length > 0) {
            displayTasks.forEach(t => {
                const row = document.createElement('div');
                row.className = 'heartbeat-task-row';

                const idSpan = document.createElement('span');
                idSpan.className = 'heartbeat-task-id';
                idSpan.textContent = t.task_id.substring(0, 12) + '¬∑¬∑¬∑';
                idSpan.title = t.task_id;

                const typeSpan = document.createElement('span');
                typeSpan.className = 'heartbeat-task-type';
                typeSpan.textContent = t.task_type;

                const taskStatusCls = getStatusBadgeClass((t.status || 'pending').toLowerCase());
                const taskBadge = document.createElement('span');
                taskBadge.className = `badge ${taskStatusCls}`;
                taskBadge.textContent = t.status || 'running';

                row.appendChild(idSpan);
                row.appendChild(typeSpan);
                row.appendChild(taskBadge);

                // Show execution_status chip when known (from heartbeat response).
                if (t.execution_status) {
                    const execBadge = document.createElement('span');
                    const execCls = t.execution_status === 'in_progress' ? 'exec-in-progress'
                                  : t.execution_status === 'completed'   ? 'exec-completed'
                                  : t.execution_status === 'failed'      ? 'exec-failed'
                                  :                                        'exec-assigned';
                    execBadge.className = `heartbeat-exec-badge ${execCls}`;
                    execBadge.textContent = t.execution_status.replace('_', ' ');
                    row.appendChild(execBadge);
                }

                // For connect_only tasks that are in_progress, show a gateway hint.
                if (t.task_type === 'connect_only' && t.execution_status === 'in_progress') {
                    const hint = document.createElement('span');
                    hint.className = 'heartbeat-gateway-hint';
                    hint.title = 'This node should have its DataPlaneGateway active and polling /gateway-sessions';
                    hint.textContent = 'üåê gateway mode';
                    row.appendChild(hint);
                }

                tasksList.appendChild(row);
            });
            tasksSection.hidden = false;
        } else {
            const empty = document.createElement('div');
            empty.className = 'heartbeat-task-row';
            empty.style.color = 'var(--text-muted)';
            empty.textContent = 'No active tasks currently assigned to this node.';
            tasksList.appendChild(empty);
            tasksSection.hidden = false;
        }
    }

    async function openHeartbeatModal(nodeId, nodeStatus) {
        document.getElementById('heartbeat-node-id').textContent = nodeId;
        document.getElementById('heartbeat-node-status').textContent = nodeStatus;

        // Populate health score from the already-fetched global nodes array.
        const nodeData = (typeof nodes !== 'undefined' ? nodes : []).find(n => n.node_id === nodeId);
        const healthEl = document.getElementById('heartbeat-node-health');
        if (nodeData && typeof nodeData.health_score === 'number') {
            healthEl.textContent = nodeData.health_score.toFixed(1) + '%';
        } else {
            healthEl.textContent = '‚Äî';
        }
        const messageEl = document.getElementById('heartbeat-message');
        messageEl.textContent = '';
        messageEl.className = 'heartbeat-status-message';
        messageEl.hidden = true;
        
        // Enable the send button
        const sendBtn = document.getElementById('send-heartbeat-btn');
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send Heartbeat';
        sendBtn.removeAttribute('data-mode');
        
        // Store node ID for the send button
        sendBtn.setAttribute('data-node-id', nodeId);

        // Populate connected tasks (active only ‚Äî completed/failed appear in Activity Log)
        renderHeartbeatTasks(nodeId);

        // Pre-populate activity log with all task activity for this node
        const pingLog = document.getElementById('heartbeat-ping-log');
        const pingEntries = document.getElementById('heartbeat-ping-entries');
        pingEntries.textContent = '';

        // Active tasks: currently assigned to this node and not yet in a terminal status
        const activeNodeTasks = tasks.filter(t =>
            Array.isArray(t.assigned_nodes) && t.assigned_nodes.includes(nodeId) &&
            t.status !== 'completed' && t.status !== 'failed');
        // Finished tasks: currently or formerly assigned to this node and reached a terminal status
        const finishedNodeTasks = tasks.filter(t =>
            (Array.isArray(t.assigned_nodes) && t.assigned_nodes.includes(nodeId) ||
             Array.isArray(t.former_assigned_nodes) && t.former_assigned_nodes.includes(nodeId)) &&
            (t.status === 'completed' || t.status === 'failed'));
        // Cleared tasks: formerly assigned to this node but cleared before reaching a terminal status
        const clearedNodeTasks = tasks.filter(t =>
            Array.isArray(t.former_assigned_nodes) && t.former_assigned_nodes.includes(nodeId) &&
            !(Array.isArray(t.assigned_nodes) && t.assigned_nodes.includes(nodeId)) &&
            t.status !== 'completed' && t.status !== 'failed');

        // Cleared tasks recorded in heartbeat history (tasks deleted after being assigned to this node)
        let deletedClearedEvents = [];
        try {
            const res = await fetch(`${apiBaseUrl}/api/v1/nodes/${encodeURIComponent(nodeId)}/heartbeat/activity`, {
                headers: getAuthHeaders(),
            });
            if (res.ok) {
                const data = await res.json();
                deletedClearedEvents = data.events || [];
            }
        } catch (_) {}

        const hasAnyActivity = activeNodeTasks.length > 0 || finishedNodeTasks.length > 0 || clearedNodeTasks.length > 0 || deletedClearedEvents.length > 0;
        if (hasAnyActivity) {
            activeNodeTasks.forEach(t => {
                addHeartbeatPingEntry(pingEntries, `Task ${t.task_id.substring(0, 12)}¬∑¬∑¬∑ [${t.task_type}] ‚Äî ${t.status} (active)`, 'ok');
            });
            finishedNodeTasks.forEach(t => {
                if (t.task_type === 'connect_only' && t.status === 'completed') {
                    addHeartbeatPingEntry(pingEntries, `Task ${t.task_id.substring(0, 12)}¬∑¬∑¬∑ [connect_only] ‚Äî session completed ‚úì`, 'ok');
                } else {
                    const cls = t.status === 'completed' ? 'ok' : 'err';
                    const symbol = t.status === 'completed' ? '‚úì' : '‚úó';
                    addHeartbeatPingEntry(pingEntries, `Task ${t.task_id.substring(0, 12)}¬∑¬∑¬∑ [${t.task_type}] ‚Äî finished (${t.status}) ${symbol}`, cls);
                }
            });
            clearedNodeTasks.forEach(t => {
                addHeartbeatPingEntry(pingEntries, `Task ${t.task_id.substring(0, 12)}¬∑¬∑¬∑ [${t.task_type}] ‚Äî cleared from node`, 'err');
            });
            deletedClearedEvents.forEach(ev => {
                const shortId = (ev.task_id || '').substring(0, 12);
                addHeartbeatPingEntry(pingEntries, `Task ${shortId}¬∑¬∑¬∑ [${ev.task_type}] ‚Äî cleared`, 'err');
            });
            pingLog.hidden = false;
        } else {
            pingLog.hidden = true;
        }
        
        document.getElementById('heartbeat-modal-overlay').classList.add('open');
        document.getElementById('heartbeat-modal-overlay').setAttribute('aria-hidden', 'false');
    }

    function closeHeartbeatModal() {
        document.getElementById('heartbeat-modal-overlay').classList.remove('open');
        document.getElementById('heartbeat-modal-overlay').setAttribute('aria-hidden', 'true');

        // Reset the send button to Send mode
        const sendBtn = document.getElementById('send-heartbeat-btn');
        sendBtn.textContent = 'Send Heartbeat';
        sendBtn.disabled = false;
        sendBtn.removeAttribute('data-mode');

        // Clear any messages
        const messageEl = document.getElementById('heartbeat-message');
        messageEl.textContent = '';
        messageEl.hidden = true;
        messageEl.className = 'heartbeat-status-message';

        // Reset live stat fields
        document.getElementById('heartbeat-node-status').textContent = '‚Äî';
        document.getElementById('heartbeat-node-health').textContent = '‚Äî';

        // Clear tasks section and ping log
        document.getElementById('heartbeat-tasks-section').hidden = true;
        document.getElementById('heartbeat-tasks-list').textContent = '';
        document.getElementById('heartbeat-ping-log').hidden = true;
        document.getElementById('heartbeat-ping-entries').textContent = '';
    }

    async function sendNodeHeartbeat() {
        const sendBtn = document.getElementById('send-heartbeat-btn');
        const nodeId = sendBtn.getAttribute('data-node-id');
        const messageEl = document.getElementById('heartbeat-message');
        
        if (!nodeId) {
            return;
        }

        const originalText = sendBtn.textContent;
        sendBtn.textContent = 'Sending...';
        sendBtn.disabled = true;
        messageEl.textContent = '';
        messageEl.className = 'heartbeat-status-message';

        // Show ping activity log
        const pingLog = document.getElementById('heartbeat-ping-log');
        const pingEntries = document.getElementById('heartbeat-ping-entries');
        pingLog.hidden = false;

        // Add a separator if the log already has pre-populated task entries
        if (pingEntries.children.length > 0) {
            addHeartbeatPingEntry(pingEntries, '‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî');
        }

        addHeartbeatPingEntry(pingEntries, `PUT ${apiBaseUrl}/api/v1/nodes/${nodeId}/heartbeat`);

        try {
            const t0 = Date.now();
            const res = await fetch(`${apiBaseUrl}/api/v1/nodes/${encodeURIComponent(nodeId)}/heartbeat`, {
                method: 'PUT',
                headers: getAuthHeaders(),
            });
            const elapsed = Date.now() - t0;

            if (res.ok) {
                const data = await res.json();
                addHeartbeatPingEntry(pingEntries, `HTTP ${res.status} ‚Äî ${elapsed}ms`, 'ok');

                // Update live node stats in the modal header from the fresh response.
                if (data.node_status) {
                    document.getElementById('heartbeat-node-status').textContent = data.node_status;
                }
                if (typeof data.health_score === 'number') {
                    document.getElementById('heartbeat-node-health').textContent = data.health_score.toFixed(1) + '%';
                }

                // Build success message showing live node stats (safe DOM construction ‚Äî no innerHTML).
                const successMsg = document.createElement('div');
                const p1 = document.createElement('p');
                p1.textContent = '‚úì Heartbeat sent successfully!';
                const p2 = document.createElement('p');
                p2.textContent = `Timestamp: ${data.timestamp || new Date().toISOString()}`;
                const p3 = document.createElement('p');
                // Prefer data.active_tasks (integer from backend); fall back to
                // assigned_tasks array length only if active_tasks is absent.
                const activeCnt = typeof data.active_tasks === 'number'
                    ? data.active_tasks
                    : (Array.isArray(data.assigned_tasks) ? data.assigned_tasks.length : 0);
                const healthStr = typeof data.health_score === 'number' ? ` ¬∑ Health: ${data.health_score.toFixed(1)}%` : '';
                const statusStr = data.node_status ? ` ¬∑ Status: ${data.node_status}` : '';
                p3.textContent = `Active tasks: ${activeCnt}${healthStr}${statusStr}`;
                successMsg.appendChild(p1);
                successMsg.appendChild(p2);
                successMsg.appendChild(p3);
                messageEl.textContent = '';
                messageEl.appendChild(successMsg);
                messageEl.classList.add('success');
                messageEl.hidden = false;

                // Log each assigned task with its execution_status.
                const assignedTasks = Array.isArray(data.assigned_tasks) ? data.assigned_tasks : [];
                assignedTasks.forEach(t => {
                    const execLabel = t.execution_status ? ` [${t.execution_status.replace('_', ' ')}]` : '';
                    addHeartbeatPingEntry(pingEntries,
                        `Task ${(t.task_id || '').substring(0, 12)}¬∑¬∑¬∑ [${t.task_type}]${execLabel}`, 'ok');
                });
                if (assignedTasks.length === 0) {
                    addHeartbeatPingEntry(pingEntries, 'No active task assignments', 'ok');
                }

                showToast(`Heartbeat sent for ${nodeId}`);
                await fetchData();
                // Re-render tasks section using the fresh data from the heartbeat response.
                renderHeartbeatTasks(nodeId, assignedTasks);

                // Change button to "Close" by setting a flag
                sendBtn.textContent = 'Close';
                sendBtn.disabled = false;
                sendBtn.setAttribute('data-mode', 'close');
            } else {
                addHeartbeatPingEntry(pingEntries, `HTTP ${res.status} ‚Äî ${elapsed}ms`, 'err');
                const err = await res.json();
                messageEl.textContent = `‚úó Failed to send heartbeat: ${err.message || 'Unknown error'}`;
                messageEl.classList.add('error');
                messageEl.hidden = false;
                showToast(err.message || 'Failed to send heartbeat', true);
                sendBtn.textContent = originalText;
                sendBtn.disabled = false;
                sendBtn.removeAttribute('data-mode');
            }
        } catch (err) {
            addHeartbeatPingEntry(pingEntries, `Error: ${err.message}`, 'err');
            messageEl.textContent = `‚úó Network error: ${err.message}`;
            messageEl.classList.add('error');
            messageEl.hidden = false;
            showToast('Network error: ' + err.message, true);
            sendBtn.textContent = originalText;
            sendBtn.disabled = false;
            sendBtn.removeAttribute('data-mode');
        }
    }

    function addHeartbeatPingEntry(container, text, cls) {
        const entry = document.createElement('div');
        entry.className = 'heartbeat-ping-entry' + (cls ? ' ' + cls : '');
        entry.textContent = `[${new Date().toISOString()}] ${text}`;
        container.appendChild(entry);
    }

    function renderNodes(nodes) {
        const tbody = document.getElementById('nodes-table');
        if (!nodes.length) {
            tbody.innerHTML = '<tr class="empty-row"><td colspan="5">No nodes registered yet</td></tr>';
            return;
        }
        tbody.innerHTML = nodes.map(n => {
            const isOwner = currentUserId && n.owner_id === currentUserId;
            const canEject = isOwner && n.status !== 'rejected' && n.status !== 'offline';
            const statusClass = getStatusBadgeClass((n.status || '').toLowerCase());
            // Colour-code health bar: green ‚â•70, amber ‚â•40, red <40.
            // When health_score is missing show a neutral grey bar at 0% width.
            const healthPct = typeof n.health_score === 'number' ? n.health_score : null;
            const healthDisplay = healthPct !== null ? healthPct.toFixed(1) + '%' : '‚Äî';
            const healthWidth  = healthPct !== null ? healthPct : 0;
            const healthColour = healthPct === null ? '#475569'
                               : healthPct >= 70   ? 'var(--accent)'
                               : healthPct >= 40   ? 'var(--amber)'
                               :                     'var(--red)';

            return `
                <tr>
                    <td><span class="mono">${escapeHtml(n.node_id)}</span></td>
                    <td>${escapeHtml(n.region)}</td>
                    <td>${escapeHtml(n.node_type)}</td>
                    <td>
                        <div class="health-wrap">
                            <span class="health-num">${healthDisplay}</span>
                            <div class="health-bar">
                                <div class="health-fill" style="width:${healthWidth}%;background:${healthColour}"></div>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="status-cell">
                            <span class="badge ${statusClass}">${escapeHtml(n.status)}</span>
                            ${canEject ? `<button class="eject-btn" onclick='handleEjectNode(${JSON.stringify(n.node_id)}, this)'>Eject</button>` : ''}
                            ${isOwner ? `<button class="heartbeat-btn" onclick='handleHeartbeat(${JSON.stringify(n.node_id)}, this)' title="Open heartbeat modal for ${escapeHtml(n.node_id)}" aria-label="Send heartbeat for ${escapeHtml(n.node_id)}">Heartbeat</button>` : ''}
                            ${isOwner && n.observability_port ? `<button class="observability-btn" onclick='handleViewObservability(${JSON.stringify(n.node_id)}, ${n.observability_port})'>View</button>` : ''}
                        </div>
                    </td>
                </tr>
            `;
        }).join('');
    }

    function renderTasks(tasks) {
        const tbody = document.getElementById('tasks-table');
        if (!tasks.length) {
            tbody.innerHTML = '<tr class="empty-row"><td colspan="7">No tasks submitted yet</td></tr>';
            return;
        }

        const activeTaskIds = new Set(tasks.map(t => t.task_id));
        for (const taskId of taskProgressMemory.keys()) {
            if (!activeTaskIds.has(taskId)) {
                taskProgressMemory.delete(taskId);
            }
        }

        tbody.innerHTML = tasks.map(t => {
            if (t.status === 'completed') {
                lockTaskCompletion(t.task_id);
            }
            const projection = estimateTaskProgress(t);
            const effectiveStatus = getEffectiveTaskStatus(t, projection);
            const cls = effectiveStatus === 'completed' ? 'badge-completed'
                      : effectiveStatus === 'failed'    ? 'badge-failed'
                      : effectiveStatus === 'running'   ? 'badge-running'
                      :                                  'badge-pending';
            const nodeDisplay = t.task_type === 'connect_only'
                ? (effectiveStatus === 'completed'
                    ? 'Session ended (disconnected)'
                    : (t.assigned_nodes.length > 0
                        ? `Connected via node: ${t.assigned_nodes.join(', ')}`
                        : 'Awaiting node assignment'))
                : (effectiveStatus === 'completed'
                    ? 'Disconnected from nodes'
                    : (effectiveStatus === 'running'
                        ? (t.assigned_nodes.length > 0
                            ? `Running on: ${t.assigned_nodes.join(', ')}`
                            : `${t.assigned_nodes.length} nodes`)
                        : (t.assigned_nodes.length > 0
                            ? `Pending (${t.assigned_nodes.length} assigned, waiting for more)`
                            : 'Awaiting node assignment')));
            return `
                <tr>
                    <td><span class="mono-dim">${t.task_id.substring(0, 12)}¬∑¬∑¬∑</span></td>
                    <td>${t.task_type}</td>
                    <td><span class="badge ${cls}">${effectiveStatus}</span></td>
                    <td class="mono-dim">${projection.progressLabel}<br><span title="${projection.etaTooltip}">${projection.etaLabel}</span></td>
                    <td class="mono-dim">${nodeDisplay}</td>
                    <td class="mono-dim">${new Date(t.created_at).toLocaleString()}</td>
                    <td class="task-action-cell">
                        <div class="task-action-group">
                            <button type="button" class="btn btn-sm btn-danger" data-task-clear="${t.task_id}" data-task-status="${effectiveStatus}" data-task-nodes="${t.assigned_nodes.length}">Clear</button>
                            ${effectiveStatus === 'completed'
                                ? `<button type="button" class="btn btn-sm" data-task-view="${t.task_id}">View Result</button>`
                                : ''}
                        </div>
                    </td>
                </tr>
            `;
        }).join('');
    }

    function getEffectiveTaskStatus(task, projection = null) {
        if (task.status === 'completed' || task.status === 'failed') {
            return task.status;
        }

        if (isTaskCompletionLocked(task.task_id)) {
            return 'completed';
        }

        // Trust the backend status - it knows if there are enough nodes
        // 'running' means min_nodes requirement is met
        // 'pending' means waiting for more nodes (even if some are assigned)
        return task.status;
    }

    function openTaskResultModal(task) {
        selectedCompletedTask = task;

        const resultPayload = task.result ?? { message: 'Task completed (no structured payload returned).' };
        const prettyPayload = JSON.stringify(resultPayload, null, 2);

        document.getElementById('result-task-id').textContent = task.task_id;
        document.getElementById('result-task-type').textContent = task.task_type;
        document.getElementById('result-task-payload').innerHTML = escapeHtml(prettyPayload);

        const modal = document.getElementById('task-result-modal-overlay');
        modal.classList.add('open');
        modal.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
    }

    function closeTaskResultModal() {
        const modal = document.getElementById('task-result-modal-overlay');
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = '';
    }

    function downloadSelectedTaskResult() {
        if (!selectedCompletedTask) {
            showToast('No completed task selected.', true);
            return;
        }

        const filename = `task-result-${selectedCompletedTask.task_id}.json`;
        const payload = selectedCompletedTask.result ?? { message: 'Task completed (no structured payload returned).' };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = filename;
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
        URL.revokeObjectURL(url);

        showToast(`Downloaded ${filename}`);
    }

    function sendSelectedTaskResultEmail() {
        if (!selectedCompletedTask) {
            showToast('No completed task selected.', true);
            return;
        }

        const payload = selectedCompletedTask.result ?? { message: 'Task completed (no structured payload returned).' };
        const subject = encodeURIComponent(`Ambient AI VCP Task Result: ${selectedCompletedTask.task_id}`);
        const body = encodeURIComponent([
            `Task ID: ${selectedCompletedTask.task_id}`,
            `Task Type: ${selectedCompletedTask.task_type}`,
            '',
            'Result:',
            JSON.stringify(payload, null, 2)
        ].join('\n'));

        window.location.href = `mailto:?subject=${subject}&body=${body}`;
        showToast('Opened your email app with the task result.');
    }

    function estimateTaskProgress(task) {
        const nowMs = Date.now();
        const createdMs = Date.parse(task.created_at) || nowMs;
        const elapsedSec = Math.max(0, (nowMs - createdMs) / 1000);
        const baselineSec = taskDurationByTypeSec[task.task_type] || 480;
        const effectiveStatus = getEffectiveTaskStatus(task);
        const isConnectOnlyConnected = task.task_type === 'connect_only'
            && effectiveStatus === 'running'
            && task.assigned_nodes.length > 0;

        if (isConnectOnlyConnected) {
            taskProgressMemory.set(task.task_id, {
                percent: 100,
                sampledAtMs: nowMs,
            });

            return {
                percent: 100,
                progressLabel: 'Connected',
                etaLabel: 'ETA disabled',
                etaTooltip: 'Connect-only session established. ETA is disabled once a node is attached.'
            };
        }

        const projectedTotalSec = effectiveStatus === 'pending'
            ? Math.max(20, baselineSec * 1.2)
            : Math.max(30, baselineSec);

        let estimatedProgress = (elapsedSec / projectedTotalSec) * 100;
        if (effectiveStatus === 'pending') {
            estimatedProgress = Math.min(estimatedProgress, 85);
        } else if (effectiveStatus === 'running') {
            estimatedProgress = Math.max(estimatedProgress, 8);
            estimatedProgress = Math.min(estimatedProgress, 99);
        } else if (effectiveStatus === 'failed') {
            estimatedProgress = 0;
        } else if (effectiveStatus === 'completed') {
            estimatedProgress = 100;
        }

        const previous = taskProgressMemory.get(task.task_id) || { percent: 0, sampledAtMs: nowMs };
        const minIncrease = effectiveStatus === 'running'
            ? ((nowMs - previous.sampledAtMs) / 1000) * 0.2
            : 0;
        const monotonicProgress = effectiveStatus === 'completed' || effectiveStatus === 'failed'
            ? estimatedProgress
            : Math.max(previous.percent + minIncrease, estimatedProgress);
        const boundedProgress = Math.min(100, Math.max(0, monotonicProgress));

        taskProgressMemory.set(task.task_id, {
            percent: boundedProgress,
            sampledAtMs: nowMs,
        });

        if (effectiveStatus === 'completed') {
            return {
                percent: 100,
                progressLabel: '100%',
                etaLabel: 'Completed',
                etaTooltip: 'Task completed successfully.'
            };
        }

        if (effectiveStatus === 'failed') {
            return {
                percent: 0,
                progressLabel: '0%',
                etaLabel: 'Failed',
                etaTooltip: 'Task failed before completion.'
            };
        }

        if (effectiveStatus === 'pending') {
            return {
                percent: Math.round(Math.max(0, Math.min(5, boundedProgress))),
                progressLabel: `${Math.round(Math.max(0, Math.min(5, boundedProgress)))}%`,
                etaLabel: 'Awaiting node',
                etaTooltip: 'ETA starts once the task is connected to at least one node.'
            };
        }

        const remainingSec = Math.max(0, projectedTotalSec - elapsedSec);
        const etaLabel = remainingSec < 60
            ? `ETA ${Math.ceil(remainingSec)}s`
            : `ETA ${Math.ceil(remainingSec / 60)}m`;

        return {
            percent: Math.round(boundedProgress),
            progressLabel: `${Math.round(boundedProgress)}%`,
            etaLabel,
            etaTooltip: `AI projection: ~${Math.round(projectedTotalSec)}s total based on task type and elapsed time.`
        };
    }

    document.getElementById('register-node-form').addEventListener('submit', async (e) => {
        e.preventDefault();

        if (!requireApiConnection('register a node')) {
            return;
        }

        const btn = e.target.querySelector('[type="submit"]');
        btn.textContent = 'Registering...';
        btn.disabled = true;

        const body = {
            node_id:  document.getElementById('node-id').value,
            region:   document.getElementById('region').value,
            node_type: document.getElementById('node-type').value,
            capabilities: {
                bandwidth_mbps: parseFloat(document.getElementById('bandwidth').value),
                cpu_cores:      parseInt(document.getElementById('cpu-cores').value),
                memory_gb:      parseFloat(document.getElementById('memory').value),
                gpu_available:  false,
            }
        };

        try {
            const res = await fetch(`${apiBaseUrl}/api/v1/nodes`, {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify(body),
            });
            if (res.ok) {
                showToast('Node registered successfully');
                e.target.reset();
                fetchData();
            } else {
                const err = await res.json();
                showToast(err.message || 'Registration failed', true);
            }
        } catch (err) {
            showToast('Network error: ' + err.message, true);
        } finally {
            btn.textContent = 'Register Node';
            btn.disabled = false;
        }
    });

    document.getElementById('open-task-modal-btn').addEventListener('click', openTaskModal);
    document.getElementById('close-task-modal-btn').addEventListener('click', closeTaskModal);
    document.getElementById('cancel-task-modal-btn').addEventListener('click', closeTaskModal);
    document.getElementById('task-type').addEventListener('change', updateTaskDefaults);
    document.getElementById('task-min-nodes').addEventListener('input', validateTaskForm);
    document.getElementById('task-max-exec').addEventListener('input', validateTaskForm);
    document.getElementById('task-inputs').addEventListener('input', validateTaskForm);
    document.getElementById('convert-inputs-btn').addEventListener('click', () => {
        convertPlainTextInputsToJson();
        validateTaskForm();
    });

    document.getElementById('task-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'task-modal-overlay') {
            closeTaskModal();
        }
    });

    document.getElementById('task-result-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'task-result-modal-overlay') {
            closeTaskResultModal();
        }
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && document.getElementById('task-modal-overlay').classList.contains('open')) {
            closeTaskModal();
        }
        if (e.key === 'Escape' && document.getElementById('task-result-modal-overlay').classList.contains('open')) {
            closeTaskResultModal();
        }
    });

    async function handleClearTask(taskId, status, assignedNodes, buttonEl) {
        if (!requireApiConnection('clear tasks')) {
            return;
        }

        const isPending = status === 'pending';

        if (!isPending) {
            const needsConfirm = assignedNodes > 0
                ? `Clear this task and disconnect ${assignedNodes} assigned node${assignedNodes === 1 ? '' : 's'}?`
                : 'Clear this task from the table?';
            if (!window.confirm(needsConfirm)) {
                return;
            }
        }

        const originalLabel = buttonEl.textContent;
        buttonEl.disabled = true;
        buttonEl.textContent = 'Clearing...';

        try {
            const res = await fetch(`${apiBaseUrl}/api/v1/tasks/${taskId}`, {
                method: 'DELETE',
                headers: getAuthHeaders(),
            });

            if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                throw new Error(err.message || 'Failed to clear task.');
            }

            showToast('Task cleared successfully.');
            fetchData();
        } catch (err) {
            showToast(err.message || 'Unable to clear task.', true);
        } finally {
            buttonEl.disabled = false;
            buttonEl.textContent = originalLabel;
        }
    }

    document.getElementById('tasks-table').addEventListener('click', (e) => {
        const clearTrigger = e.target.closest('[data-task-clear]');
        if (clearTrigger) {
            const taskId = clearTrigger.getAttribute('data-task-clear');
            const status = clearTrigger.getAttribute('data-task-status') || 'pending';
            const assignedNodes = parseInt(clearTrigger.getAttribute('data-task-nodes') || '0', 10);
            handleClearTask(taskId, status, assignedNodes, clearTrigger);
            return;
        }

        const trigger = e.target.closest('[data-task-view]');
        if (!trigger) return;

        const taskId = trigger.getAttribute('data-task-view');
        if (!requireApiConnection('view completed task results')) {
            return;
        }

        fetch(`${apiBaseUrl}/api/v1/tasks`, { headers: getAuthHeaders() })
            .then((res) => res.ok ? res.json() : Promise.reject(new Error('Failed to fetch tasks')))
            .then((tasks) => {
                const task = tasks.find((t) => {
                    if (t.task_id !== taskId) return false;
                    return getEffectiveTaskStatus(t, estimateTaskProgress(t)) === 'completed';
                });
                if (!task) {
                    showToast('Completed task result no longer available.', true);
                    return;
                }
                openTaskResultModal(task);
            })
            .catch((err) => showToast(err.message || 'Unable to load task result.', true));
    });

    document.getElementById('close-task-result-modal-btn').addEventListener('click', closeTaskResultModal);
    document.getElementById('close-task-result-modal-footer-btn').addEventListener('click', closeTaskResultModal);
    document.getElementById('download-task-result-btn').addEventListener('click', downloadSelectedTaskResult);
    document.getElementById('send-task-result-email-btn').addEventListener('click', sendSelectedTaskResultEmail);

    // Observability modal event listeners
    document.getElementById('close-observability-modal-btn').addEventListener('click', closeObservabilityModal);
    document.getElementById('close-observability-modal-footer-btn').addEventListener('click', closeObservabilityModal);
    document.getElementById('refresh-observability-btn').addEventListener('click', () => {
        const nodeId = document.getElementById('obs-node-id').textContent;
        const portText = document.getElementById('obs-port').textContent;
        const port = portText !== 'Not configured' ? parseInt(portText) : null;
        if (port) {
            fetchObservabilityData(nodeId, port);
        }
    });

    document.getElementById('observability-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'observability-modal-overlay') {
            closeObservabilityModal();
        }
    });

    // Heartbeat modal event listeners
    document.getElementById('close-heartbeat-modal-btn').addEventListener('click', closeHeartbeatModal);
    document.getElementById('close-heartbeat-modal-footer-btn').addEventListener('click', closeHeartbeatModal);
    document.getElementById('send-heartbeat-btn').addEventListener('click', (e) => {
        const btn = e.target;
        if (btn.getAttribute('data-mode') === 'close') {
            closeHeartbeatModal();
        } else {
            sendNodeHeartbeat();
        }
    });

    document.getElementById('heartbeat-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'heartbeat-modal-overlay') {
            closeHeartbeatModal();
        }
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (document.getElementById('heartbeat-modal-overlay').classList.contains('open')) {
                closeHeartbeatModal();
            } else if (document.getElementById('observability-modal-overlay').classList.contains('open')) {
                closeObservabilityModal();
            }
        }
    });

    async function submitTaskForm(formEl) {
        const btn = document.getElementById('submit-task-btn');

        if (!requireApiConnection('submit tasks')) {
            return;
        }

        if (!authToken) {
            showToast('Please login before submitting a task', true);
            return;
        }

        if (!validateTaskForm()) {
            showToast('Please fix validation errors before submitting', true);
            return;
        }

        const parsedInputs = parseTaskInputsFlexible(document.getElementById('task-inputs').value);
        if (parsedInputs === null) {
            showToast('Please provide inputs as JSON or plain text', true);
            return;
        }

        const body = {
            task_type: document.getElementById('task-type').value,
            wasm_module: null,
            inputs: parsedInputs,
            requirements: {
                min_nodes: parseInt(document.getElementById('task-min-nodes').value, 10),
                max_execution_time_sec: parseInt(document.getElementById('task-max-exec').value, 10),
                require_gpu: document.getElementById('task-require-gpu').value === 'true',
                require_proof: document.getElementById('task-require-proof').value === 'true',
            },
        };

        btn.textContent = 'Submitting...';
        btn.disabled = true;

        try {
            const res = await fetch(`${apiBaseUrl}/api/v1/tasks`, {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify(body),
            });

            if (res.ok) {
                showToast('Task submitted successfully');
                // Close immediately on success so follow-up UI refresh work cannot
                // keep the task window open if any later step errors.
                closeTaskModal();
                formEl.reset();
                document.getElementById('task-inputs').value = '';
                updateTaskDefaults();
                validateTaskForm();
                await fetchData();
            } else {
                const err = await res.json().catch(() => ({}));
                const serverMsg = err.message || err.error || '';
                showToast(serverMsg || `Task submission failed (HTTP ${res.status})`, true);
            }
        } catch (err) {
            showToast('Network error: ' + err.message, true);
        } finally {
            btn.textContent = 'Submit Task';
            btn.disabled = false;
        }
    }

    const submitTaskFormEl = document.getElementById('submit-task-form');
    document.getElementById('submit-task-btn').addEventListener('click', () => {
        submitTaskFormEl.requestSubmit();
    });

    submitTaskFormEl.addEventListener('submit', async (e) => {
        e.preventDefault();
        await submitTaskForm(e.target);
    });

    // Auth tab switching
    function showAuthTab(tab) {
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const tabs = document.querySelectorAll('.auth-tab');
        
        tabs.forEach(t => t.classList.remove('active'));
        
        if (tab === 'login') {
            loginForm.style.display = 'block';
            registerForm.style.display = 'none';
            tabs[0].classList.add('active');
        } else {
            loginForm.style.display = 'none';
            registerForm.style.display = 'block';
            tabs[1].classList.add('active');
        }
    }

    // Initialize on page load
    document.getElementById('api-url').value = apiBaseUrl;
    setConnectionStatus(false);
    document.getElementById('api-url').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            updateApiUrl();
        }
    });

    updateTaskDefaults();
    validateTaskForm();
    checkAuth();
    setInterval(() => {
        if (authToken && isApiConnected) fetchData();
    }, 5000);
</script>
</body>
</html>
